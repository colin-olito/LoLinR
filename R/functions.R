################################################################
#  Functions and Dependencies for the primary function FindLocLin(), used to find
#  the 'most linear' local regressions from a given dataset.
#
#  Run these functions



################################################################
#  Dependency -- Function TriCube():
#
# TriCube() is a function to calculate Tri-Cube weights for a given vector of values
# for an independent variable. This function is a dependency for FindLocLin(), and is
# used to calculate the weights for Weighted Least Squares Regression.

TriCube<-function(x, h) {
  c <- h+1
  z <- abs(x-x[c])/h
  ifelse(z < 1, (1 - z^3)^3, 0)
}



################################################################
#  Dependency -- Function Skew():
#
# Skew() is a function to calculate the Fisher-Pearson Standardized Third Moment
# Coefficient for a given vector of numbers. This function is a dependency for
# FindLocLin(), and is used to calculate the skewness of standardized residuals.

# Note: Compare to moments package
Skew <- function(x){
    n <- length(x)
    (n/((n-1)*(n-2))) * sum(((x-mean(x))/sd(x))^3)
}



################################################################
#  Dependency -- LinReg():
#
# LinReg() is a wrapper for a function to fit a simple linear regression using either
# weighted or unweighted least squares. The function uses matrix notation to minimize
# memory usage relative to fitting any of the Base linear model functions in R. This
# function will consist of the 'guts' of the Fit Block... I imagine that much of the
# flexibility in the FindLocLin() function will come from minor modifications to this
# bit of code.

LocReg <- function(x, y, h, weights = TRUE){

# Design Matrix #
X <- matrix(cbind(1,x), ncol=2)
    
        if(weights == FALSE){ # Use Ordinary Least Squares Regression #

            # Fit Model #
            b.hat = (solve(t(X) %*% X)) %*% t(X) %*% y
            y.hat = X %*% b.hat
            hat.mat = X %*% (solve(t(X) %*% X)) %*% t(X) %*% y
            sigma.hat = sum((y-(X %*% b.hat))^2) / length(y)
            sigma.hat.ub = sum((y - (X %*% b.hat))^2) / (length(y) - 2)
            std.resid = (y - y.hat)/sqrt(y.hat)
        }

        else{ # Use Weighted Least Squares Regression #

            # Calcualate weights #
            w <- TriCube(x=x, h=h)

            # Fit Model #
            b.hat = (solve(t(X) %*% diag(w) %*% X)) %*% t(X) %*% diag(w) %*% y
            y.hat = X %*% b.hat
            hat.mat = X %*% (solve(t(X) %*% diag(w) %*% X)) %*% t(X) %*% diag(w) %*% y
            sigma.hat = sum((y - (X %*% b.hat))^2)/length(y)
            sigma.hat.ub = sum((y-(X %*% b.hat))^2)/(length(y) - 2)
            std.resid = (y - y.hat)/sqrt(y.hat)
        }
    
##  Combine results  ##

    linfit <- list('b.hat' = as.vector(b.hat), 'y.hat' = as.vector(y.hat),
                   'hat.mat' = as.vector(hat.mat), 'sigma.hat' = as.vector(sigma.hat),
                   'sigma.hat.ub' = as.vector(sigma.hat.ub), 'std.resid' = as.vector(std.resid))
    return(linfit)
}


################################################################
#  Function FindLocLin():
# 
# FindLocLin() is a function to perform a customized LOESS regression
# to find the 25 'most linear' local regressions from a given dataset.
# 
# It accepts 5 arguments:

# -- yall:     Dependent variable
# 
# -- xall:     Independent variable
# 
# -- alpha:   The MINIMUM proportion of the dataset used to fit
#                     local regressions. Equivalent to the "smoothing
#                     parameter" in standard LOESS regression
# 
# -- weights: Option to perform Weighted Least Squares vs. Ordinary
#                     Least Squares regression. Weights are calculated
#                     using a TriCube function. Default setting is weights = TRUE.
# 
# -- plots:    Option to output plots of the the top 25 results as
#                     ranked by goodness of fit and skewness of the
#                     standardized residuals.
# 
# Overview:
# 
# FindLocLin() is a customized LOESS regression procedure with a rather
# specific purpose: to find the most linear region of a relation between
# two continuous variables. The original motivation for this function was
# to standardize estimates of an organism's resting  metabolic rate from
# oxygen consumption data. O2 consumption data typically depict a initial
# period of noise, followed by a relatively linear decline, which gradually
# decelerates as the animal becomes stressed. Point estimates of resting
# metabolic rate aim to find the 'sweet spot' of linear O2 decline.
# Standard LOESS procedures aren't particularly useful for this purpose
# because they emphasise data visualization and interpolation from the
# overall prediction line. In contrast, the motivation for FindLocLin() is to
# actually inspect each of the local linear regressions generated by a 1st
# order LOESS regression, and find the one that represents the best
# compromise between linearity, goodness of fit, and the proportion of
# the data being used to fit the local regression.
 
# Briefly, FindLocLin() finds the 25 'most linear' local regressions from
# a given dataset. To do this, the user provides a lower limit for the
# proportion of the full dataset used to fit the local regressions. Starting
# with this lower limit, FindLocLin() iteratively fits local regressions while
# moving the centerpoint of the local regression through the full range of
# the dataset, and then iteratively increases the proportion of the data set
# being used to fit each local regression until it is eventually fitting the
# entire data set. For each local regression, FindLocLin() calculates
# goodness of fit using R^2, and calculates the skewness of the
# standardized residuals (Fisher-Pearson Standardized Third Moment
# Coefficient). FindLocLin() then ranks the results according to these
# metrics, and returns the 25 'best' local linear regressions, as well as
# plots of each.
################################################################



FindLocLin <- function(yall, xall, alpha, weights = TRUE, plots = TRUE) {

#  Initialize results  #
res <- array(,dim=c(1,7))

#  Initialize minimum data window  #
h <- ceiling((alpha*length(yall))/2)

#  Start Loops  #
while((2*h)+1 <= length(yall)) {
    for (i in 1:length(yall)) {

        if (i-h < 1 | i+h > length(yall))
            next
        else {
            y <- yall[c((i-h) : (i+h))]
            x <- xall[c((i-h) : (i+h))]
        }

        
##  FIT BLOCK  ##        
        LocFit <- LocReg(x=x, y=y, h=h, weights=weights)
        
        ##  Calculate Statistics of Interest  ##
        r2 <- 1 - ((sum((y - LocFit$y.hat)^2)) / (sum((y - mean(y))^2)))
        alph <- ((2*h)+1) / length(yall)
        res <- rbind(res,c(i, h, alph, LocFit$b.hat[1], LocFit$b.hat[2], Skew(x = LocFit$std.resid), r2))
    }
    h <- h+1
}

##  Compile and Sort Results  ##
res <- data.frame(res[-1,])

#  Calculate combined metric (L) for linearity & fit  #
#L <- ((min(abs(res[,6])) + abs(res[,6]))/sd(res[,6])) + ((max(res[,7]) - res[,7])/sd(res[,7]))
L <- ((min(res[,6]) + abs(res[,6]))/sd(res[,6])) + ((max(res[,7]) - res[,7])/sd(res[,7]))
res <- cbind(res,L)

res <- data.frame(res[order(res[,8]),][1:25,])
names(res) <- c("i","h", "alpha", "b0","b1","skew","r2", "L")


    
################################
##  Plots to accompany best results  ##

if(plots==TRUE) {

pdf(file="testplots.pdf", height=15, width=15)
par(mfrow=c(5,5))

for(i in 1:nrow(res)) {
ytemp <- yall[c((res$i[i]-res$h[i]) : (res$i[i]+res$h[i]))]
xtemp <- xall[c((res$i[i]-res$h[i]) : (res$i[i]+res$h[i]))]

plot(yall ~ xall, pch=21, col='grey80', main=i)
points(ytemp ~ xtemp, pch=21, bg=1, col=2,ask=TRUE)
abline(coef=c(res$b0[i],res$b1[i]), col=2)
}
graphics.off()

dev.new()
hist(res$b1, breaks=25)

}


##  Return Results  ##    
return(res)

}  #*** END OF FUNCTION



















###################################################
#  Function PlotBest():
#
#  Followup function for use with FindLocLin(). Generates residual
#    plots and stand alone scatterplot for a local linear regression
#    chosen by the user from the FindLocLin() output data frame.
#
#    Takes 5 arguments:
#      -- res:  FindLocLin() output data frame
#
#      -- best:  row number corresponding to the local linear
#                 regression from FindLocLIn output the user
#                 wishes to plot/inspect. Usually the 'best'
#                 linear regression.
#      -- yall:  Same yall input data as for FindLocLin()
#      -- xall:  Same xall input data as for FindLocLin()
#      -- weights:  As in FindLocLin, an option to perfoyrm
#                     ordinarly leas squares, or weighted
#                     least squares regression (using TriCube)
#                     weights.
###################################################

PlotBest <- function(res, best, yall, xall, weights = TRUE) {

# Recover data window for chosen local regression model   
y <- yall[c((res$i[best] - res$h[best]) : (res$i[best] + res$h[best]))]
x <- xall[c((res$i[best] - res$h[best]) : (res$i[best] + res$h[best]))]

##  FIT BLOCK  ##        

LocFit <- LocReg(x=x, y=y, h=res$h[best], weights=weights)

    
##  Residual Plots  ##
#pdf(file="residplots.pdf", height=10, width=10)
dev.new()
par(mfrow=c(2,2))
plot(LocFit$std.resid ~ x,
       xlab="x", ylab="y", main="Std. Residuals ~ x")
abline(h=0,col=1, lwd=2)
lf1 <- loess(LocFit$std.resid ~ x)
points(x, lf1$fitted, type='l', col=2, lwd=2)
    
plot(LocFit$std.resid ~ LocFit$y.hat,
       xlab="Fitted Values",ylab="Standardized Residuals",main="Std. Residuals ~ Fitted Values")
abline(h=0,col=1, lwd=2)
lf2 <- loess(LocFit$std.resid ~ LocFit$y.hat)
points(LocFit$y.hat, lf2$fitted, type='l', col=2, lwd=2)

qqnorm(LocFit$std.resid, main="QQNorm plot of Std. Residuals")
qqline(LocFit$std.resid,col=2)

hist(LocFit$std.resid, xlab="Standardized Residuals", ylab="Density",breaks=20, main="Density Plot of Std. Residuals")
#graphics.off()
    
##  Overall Regression Plot  ##
dev.new()
plot(yall ~ xall, pch=21, col='grey80', ask=TRUE,
                  main=expression(paste("Best Local Regression: ",b[o], " = ", b.hat[1,], " = ", b.hat[2,])))
points(y ~ x, pch=21, bg=1, col=2,ask=TRUE)
abline(coef=c(LocFit$b.hat[1],LocFit$b.hat[2]), col=1)

    
}  #END OF FUNCTION









###################################################
#  Examples:
###################################################

# Colin's local data folder
data <- read.csv("~/Documents/Projects/PhD/local-lin/data/TestO2data.csv", header=TRUE, stringsAsFactors=FALSE)

y=data$D; x=data$time;



data <- read.csv("TestO2data.csv", header=TRUE, stringsAsFactors=FALSE)
head(data)
nrow(data)

results <- FindLocLin(yall=data$D, xall=data$time, alpha=0.2, weights=TRUE, plots=FALSE)
results
PlotBest(res=results, best=1, yall=data$D, xall=data$time)







